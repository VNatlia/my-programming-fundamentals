#include <iostream>
#include <vector>

using namespace std;

int main()
{
    // Task 1
    {
        vector<int> kivi = {3, 55, 7, 5, 8, 5, 324, 87, 44};  // Вхідний вектор
        int P = 5;  // Шукаємо це значення
        int index;  // Змінна для збереження індексу першого входження

        // Проходимо по вектору і знаходимо перше входження P
        for (int i = 0; i < kivi.size(); i++) {
            if (kivi[i] == P) {
                index = i;
                break;  // Зупиняємо цикл після знаходження першого входження
            }
        }

        // Виводимо результат
        if (index != 0) {
            cout << "Індекс " << P << " у масиві = " << index << endl;
        } else {
            cout << "Значення не існує" << endl;
        }

    }

      // Task #2
    {
        vector<int> kivi = {-9, 55, -7, 5, 8, 3, 90, 13, 456};

        int minPosVal = -1;  // Якщо не буде елементів які додатні, то виведемо значення -1(таких значень нема)
        bool posVal = false;  // Якщо в масиві буде додатнє значення, то будемо змінювати значення
                              // цієї змінної і використовувати в умовних операторах

        for (int i = 0; i < kivi.size(); i++) { // Циклом знову перебираємо всі елементи масиву
            if (kivi[i] > 0) {  // Перевіряємо, чи є елемент більше 0, тобто додатнім
                if (posVal == false || kivi[i] < minPosVal) {  // Якщо жодного додатнього елемента ще не знайдено
                                                              // або поточний елемент масиву менший за поточне мінімальне додатнє значення
                    minPosVal = kivi[i]; // Перезаписую мінімальне значення -1,
                                        // на значення поточного елемента якщо воно менше за це значення -1
                    posVal = true; // І змінюю значення змінної на true щоб використати далі в умовному операторі
                }
            }
        }

        if (posVal == true) { // Якщо найменший елемент був знайдений і ця умова істинна, то буде виведено відповідне повідомлення
            cout << "Мінімальне значення = " << minPosVal << endl;
        } else { // Якщо хибна, то буде виведено це повідомлення
            cout << "Немає додатних значень" << endl;
        }
    }

    // Task #3
    {
        vector<int> kivi = {-9, -55, -7, 5, 8, 3, 123, 99, 45};

        int minIndex = 0; // Ініціалізую індекси мінімального
        int maxIndex = 0; // і максимального значень

        for (int i = 1; i < kivi.size(); i++) { // Завдяки циклу проходимо по всім елементам і записуємо
                                      // мінімальне та максимальне значення в змінні які були ініційовані раніше
            if (kivi[i] < kivi[minIndex]) { // Якщо значення поточного елемента < за те що я задав(0) то перезапишемо його
                minIndex = i;  // Зберігаю індекс числа мінімального значення
            }
            if (kivi[i] > kivi[maxIndex]) {
                maxIndex = i;  // Зберігаю індекс числа з максимальним значенням
            }
        }

        cout << "Мінімальне значення = " << kivi[minIndex] << endl; // Вивожу для наглядності мінімальне значення 
        cout << "Максимальне значення = " << kivi[maxIndex] << endl; // І максимальне 

        int temp = kivi[minIndex]; // Створюю тимчасову змінну для зміни значень між елементами
        kivi[minIndex] = kivi[maxIndex]; // Наступні 2 строчки процес обміну значень
        kivi[maxIndex] = temp;

        cout << "Мінімальне значення(обернене) = " << kivi[minIndex] << endl; // Вивожу значення яке було заміненл максимальним 
        cout << "Максимальне значення(обернене) = " << kivi[maxIndex] << endl; // І значення яке було замінено мінімальним 
    }

    return 0;
}